<!DOCTYPE html>
<html lang='en'><head>
    <meta charset="utf-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    
    

<title>Transfering state from server to client with Blazor WASM and prerendering</title>
<meta property="og:title" content="Transfering state from server to client with Blazor WASM and prerendering" >
<meta name="twitter:title" content="Transfering state from server to client with Blazor WASM and prerendering" >

<meta property="og:site_name" content="Erwin Kuhn">


<meta name="description" content="Blazor&#39;s server-side prerendering feels amazing, because you get something on the page instantly. Except the first time I used it, the whole page flashed with every refresh." >
<meta property="og:description" content="Blazor&#39;s server-side prerendering feels amazing, because you get something on the page instantly. Except the first time I used it, the whole page flashed with every refresh." >
<meta name="twitter:description" content="Blazor&#39;s server-side prerendering feels amazing, because you get something on the page instantly. Except the first time I used it, the whole page flashed with every refresh." >



<meta name="keywords" content="Blazor,prerendering,performance" >


<meta name="twitter:card" content="summary_large_image">

<meta property="og:type" content="article" >


<meta name="author" content="map[]" >
<meta name="twitter:creator" content="@erwinkhn" >
<meta name="twitter:site" content="@erwinkhn">


  <meta itemprop="image" content="https://erwinkn.com/img/default.png" >
  <meta property="og:image" content="https://erwinkn.com/img/default.png" >
  <meta name="twitter:image" content="https://erwinkn.com/img/default.png" >
  <meta name="twitter:image:alt" content="Homepage of Erwin Kuhn&#39;s website" >


<link rel="canonical" href="https://erwinkn.com/tricks/blazor-rehydration/" >
<meta property="twitter:url" content="https://erwinkn.com/tricks/blazor-rehydration/">
<meta property="og:url" content="https://erwinkn.com/tricks/blazor-rehydration/" >


<meta name="robots" content="index,follow" > 
<meta name="googlebot" content="index,follow" >



<meta name="generator" content="Hugo 0.82.0" />


<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<meta name="msapplication-TileColor" content="#da532c">

<meta name="theme-color" content="#fdf6e3">


    
    
    
    
    
    

    
    
    
    <link rel="stylesheet" href="/bundle.min.bac708dbbeb693be7c107dda6536b70937d9f6567a4763d4bd57f61ff3f1a128.css" integrity="">
    <script type="text/javascript" src="/prism/prism.js"></script>
    
    
    

    
    
</head><body class="flex flex-col min-h-screen bg-lightBeige xl:text-lg">
<header class="bg-darkGreenBlue text-lightBeige">
    <nav class="max-w-container mt-12 mb-4">
        <a href="https://erwinkn.com/" class='font-semibold font-display tracking-wider text-5xl md:text-6xl  '>
            Erwin Kuhn
        </a>
        
        <div class="text-xl md:text-2xl lg:text-3xl mt-1 font-medium flex flex-wrap space-x-4 justify-items-center">
            
            
            
            
            <a class=" block px-1 py-2 " href="/about/">About</a>
            
            
            
            <a class=" block px-1 py-2 " href="/blog/">Blog</a>
            
            
            
            <a class=" block px-1 py-2 " href="/now/">Now</a>
            
            
            
            <a class=" block px-1 py-2 " href="/tricks/">Tricks</a>
            
        </div>
    </nav>
    
    <svg class="wave" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none" viewBox="0 0 1440 320">
    <path fill="currentColor" fill-opacity="1"
        d="M0,128L48,144C96,160,192,192,288,181.3C384,171,480,117,576,90.7C672,64,768,64,864,80C960,96,1056,128,1152,133.3C1248,139,1344,117,1392,106.7L1440,96L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z">
    </path>
</svg>
</header><main class="flex-1 w-full text-darkGreenBlue">
<article class="max-w-container mt-10">
    <div class="prose xl:prose-lg">
        <h1>
            Transfering state from server to client with Blazor WASM and prerendering
        </h1>
        <div class="text-gray-500 tracking-wide -mt-8">
            <time class="uppercase">
                March 10, 2021
            </time>
            <span class="">
                &middot;
            </span>
            <span>
                6 min
            </span>
        </div>
        
        <div class="border-darkSanguine border-l-4 pl-4 py-1 mt-4 lg:mt-6 mb-2 font-medium italic text-xl xl:text-2xl ">
            Or how to solve the "flash" problem with Blazor server-side prerendering
        </div>
        
        
<p>I wanted to brush up my <a href="https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor">Blazor</a> skills. I had been 

<span>
  <input aria-label="Show sidenote" type="checkbox" id='sn_check-529'
         class="sn_check hidden">
  <label tabindex="0" title='I&rsquo;ll give an introduction to …'
    aria-describedby='sidenote-529' for='sn_check-529'
    class="text-darkSanguine border-darkSanguine border-b-2 border-dotted -mb-2 cursor-pointer ast-after
           xl:cursor-default xl:border-none xl:text-current">using the new .NET framework</label>
  <small id='sidenote-529'
         class="sn_content ast-before sr-only flex
                xl:not-sr-only xl:relative xl:float-right xl:clear-right xl:left-0
                xl:w-80 xl:-mr-104">
    <span class="sr-only">
      (sidenote:
    </span>
    <span class="xl:ml-1.5 leading-normal">I&rsquo;ll give an introduction to Blazor and the whole experience of putting it into production in a separate blog post.</span>
    <span class="sr-only">
      )
    </span>
  </small>
</span> in my work with <a href="https://www.vicat.fr/">Vicat</a>, an international cement &amp; concrete group based in France, to develop a modelling tool for long term roadmaps towards carbon neutrality. Coding with it was a joy, but I had doubts about its overall performance.</p>
<p>Since there&rsquo;s no better way to put a framework to the test than to build something and optimize the hell out of it, I decided to make a good old Hacker News reader using Blazor WebAssembly. That way, I could compare it with <a href="https://hnpwa.com/">the myriad of other implementations</a> out there.</p>
<p>You can see the final result of the standalone version, hosted on GitHub Pages, <a href="https://erwinkn.com/hnpwa-blazor/">here</a>.</p>
<p>The last step was to implement server-side prerendering. It enables the server to compute the HTML for the first page and serve it to the client instantly, while the Blazor runtime downloads in the background. I&rsquo;ll skip over the implementation, which is <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/prerendering-and-integration?view=aspnetcore-5.0&amp;pivots=webassembly#configuration">described in the docs</a>. Overall, it&rsquo;s easy to setup - but it requires a server, so say goodbye to static hosting like GitHub Pages.</p>
<p>The results felt really nice: no more loading indicators, instant content! Except&hellip; the whole page rendered then disappeared then rendered again every time you opened the app.</p>
<figure class='mx-auto w-full flex flex-col items-center '>
    

Turns out, your component logic will execute twice: once on the server, once in the client. That's [in the docs](https://docs.microsoft.com/en-us/aspnet/core/blazor/components/lifecycle?view=aspnetcore-5.0#stateful-reconnection-after-prerendering). What's *not* in the docs is that if you have an asynchronous API call in there, Blazor will refresh the page as soon as the call goes off, and render elements as the data arrives. Normally that's great, it makes the page more responsive. In our case that's really bad, because we get this "flash". 

If you dig a bit deeper, the fundamental problem here is that there is no state transfer between the server and the client. In other frameworks, this technique is called [rehydration](https://www.aboutmonica.com/blog/server-side-rendering-react-hydration-best-practices). The documentation linked above provides a way to solve this problem for Blazor Server, but says nothing about pre-rendering for Blazor WebAssembly.

So, here is how you do state rehydration in a Blazor WebAssembly app pre-rendered on a server:

<figure class='mx-auto w-full flex flex-col items-center '>
    

Yep, you just serialize everything and dump it onto the page.

Once the client receives the page, it can read the state directly and avoids doing the initial API call.

The idea here is to replace all your API calls with a service that will take care of serializing / deserializing the state. You provide with a function wrapping the API call, so that it can execute it on its own, and a key to store or retrieve the result.


<pre><code class='language-csharp'>
MyType items = await Cache.GetOrAdd(
    key,
    () => HttpClient.GetFromJsonAsync&lt;MyType>("api/endpoint"));
</code></pre>

Alright, time to dig into the code of our `Cache` service.

If it's running on the server, the `Cache` service does the API call and stores the result in a dictionary. This dictionary will be used down the line to serialize everything onto the page.


<pre><code class='language-csharp'>
private Dictionary&lt;string, object> Items { get; set; }
    = new Dictionary&lt;string, object>();

public async Task&lt;TResult> GetOrAdd&lt;TResult>(
    string key, Func&lt;Task<&lt;TResult>> call)
{
    if(IsRunningOnServer)
    {
        var data = await call();
        Items[key] = data;
        return data;
    }
    else
    {
        // Read from page
    }
}
</code></pre>

But before that, we have to elucidate something: how does the `Cache` service know whether it's running on the server or in the browser? 

A simple way to do that is to check whether or not we have access to a JavaScript runtime.


<pre><code class='language-csharp'>
private readonly IJSRuntime jsRuntime;
public Cache(IJSRuntime js)
{
    jsRuntime = js;
}
bool IsRunningOnServer =>
    jsRuntime.GetType().Name == "UnsupportedJavaScriptRuntime";
</code></pre>

Note that the JavaScript runtime we just injected will also be useful when we need to read the state from the page, as Blazor cannot interact with the DOM directly.

Now that the result of all our API calls have been stored in the dictionary, it's time to serialize everything onto the page. For this, we'll use a JavaScript object that will hold our data and provide us a function to retrieve it afterwards.

This JavaScript object is created by a `CacheStore.razor` component in `Server/Components`. The `supress-error` attribute is necessary, otherwise the compiler won't accept a `<script>` tag  in a Razor component. Don't worry, it works fine 😁


<pre><code class='language-html'>
@inject Cache Cache
&lt;script suppress-error="BL9992" type="text/javascript">
    window.Cache = {
        cache: @(new MarkupString(Cache.Write())),
        load: () => window.Cache.cache
    }
&lt;/script>
</code></pre>

The `Cache.Write` function simply serializes our dictionary:


<pre><code class='language-csharp'>
public string Write() => JsonSerializer.Serialize(Items);
</code></pre>

Finally, we embed our `CacheStore.razor` in the `_Host.cshtml` page on our server.

<pre><code class='language-html'>
&lt;component
    type="typeof(HnpwaBlazor.Server.Components.CacheStore)"
    render-mode="Static" />
</code></pre>

<span class="text-darkSanguine font-semibold">Important!</span> The component should be placed at the very end of `_Host.cshtml`, right before the closing `</body>` tag, to make sure all the components have loaded before it writes the state on the page.

With this, you have everything you need to get that beautiful serialized state that we've seen above. Now, it's time to read from it.

Once again, this happens in our `Cache` service. The first time someone calls the `GetOrAdd` method on the client, the cache loads the `Items` dictionary by calling the JavaScript function defined above.

For all subsequent calls, the `Cache` takes the result from the dictionary and returns it, or does an API call if it cannot find it.


<pre><code class='language-csharp'>
private bool HasLoaded { get; set; }
public async Task&lt;TResult> GetOrAdd&lt;TResult>(
    string key, Func&lt;Task<&lt;TResult>> call)
{
    if(IsRunningOnServer)
    {
        // We saw this already
    }
    else
    {
        if(!HasLoaded)
        {
            Items = await jsRuntime.InvokeAsync
                        &lt;Dictionary&lt;string, object>>("Cache.load");
            HasLoaded = true;
        }
        it(Items.Remove(key, out var item))
        {
            var json = JsonSerializer.Serialize(item);
            return JsonSerializer.Deserialize<TResult>(json);
        }
        return await call();
    }
}
</code></pre>

Note that since all our API calls go through the `Cache` service, we remove the items from the dictionary to make sure that the requests are executed normally afterwards.

Alright, we're nearly done here! The last thing we need to do is to register our `Cache` service for both the client and server and inject it into components.


<pre><code class='language-csharp'>
/* In Server/Startup.cs */
public void ConfigureServices(IServiceCollection services)
{
    services.AddScoped&lt;Cache>();
    // ...
}

/* In Client/Program.cs */
public static async Task Main(string[] args)
{
    // ...
    builder.AddScoped&lt;Cache>();
    // ...
}

/* In some component */
@inject Cache Cache
// markup
@code {
    // ...
    MyType items = await Cache.GetOrAdd(
        key,
        () => HttpClient.GetFromJsonAsync&lt;MyType>("api/endpoint"));
    // ...
}
</code></pre>

If you want to look at an actual implementation, my Hacker News Blazor reader is running [here](https://hn-blazor.azurewebsites.net/) and the code is available on [GitHub](https://github.com/erwinkn/hnpwa-blazor).

For the things I presented here, you'll mostly want to look into the [`Shared` folder](https://github.com/erwinkn/hnpwa-blazor/tree/main/Shared). There's additional trickery involved with another `ApiService` on top of cache because I have a build process that publishes the app both as standalone and server-hosted. Feel free to ignore that.

Hope this proves useful and feel free to [contact me](mailto:erwin.kuhn@protonmail.com) if anything seems unclear!
    
    <figcaption>Elegant, right?</figcaption>
    
</figure>
    
    <figcaption>See that loading indicator that appears after the browser gets the page?</figcaption>
    
</figure>

    </div>
</article>

    </main><footer
    class='w-full mt-48 text-center border-t border-darkGreenBlue border-opacity-10 p-4 text-xs text-darkGreenBlue text-opacity-60'>
    <p>
        Made with
        <a href="https://gohugo.io" class="thick-underline-70 hover-highlight">Hugo</a>
        and
        <a href="https://tailwindcss.com" class="thick-underline-70 hover-highlight">TailwindCSS</a>
    </p>
    <p class="mt-1">
        © 2020-present Erwin Kuhn. All rights reserved.
    </p>
</footer>
</body>

</html>